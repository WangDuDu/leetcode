package dynamicprogramming.zeroonebackpack;

//ç»™ä½ ä¸€ä¸ª åªåŒ…å«æ­£æ•´æ•° çš„ éç©º æ•°ç»„ nums ã€‚è¯·ä½ åˆ¤æ–­æ˜¯å¦å¯ä»¥å°†è¿™ä¸ªæ•°ç»„åˆ†å‰²æˆä¸¤ä¸ªå­é›†ï¼Œä½¿å¾—ä¸¤ä¸ªå­é›†çš„å…ƒç´ å’Œç›¸ç­‰ã€‚ 
//
// 
//
// ç¤ºä¾‹ 1ï¼š 
//
// 
//è¾“å…¥ï¼šnums = [1,5,11,5]
//è¾“å‡ºï¼štrue
//è§£é‡Šï¼šæ•°ç»„å¯ä»¥åˆ†å‰²æˆ [1, 5, 5] å’Œ [11] ã€‚ 
//
// ç¤ºä¾‹ 2ï¼š 
//
// 
//è¾“å…¥ï¼šnums = [1,2,3,5]
//è¾“å‡ºï¼šfalse
//è§£é‡Šï¼šæ•°ç»„ä¸èƒ½åˆ†å‰²æˆä¸¤ä¸ªå…ƒç´ å’Œç›¸ç­‰çš„å­é›†ã€‚
// 
//
// 
//
// æç¤ºï¼š 
//
// 
// 1 <= nums.length <= 200 
// 1 <= nums[i] <= 100 
// 
// Related Topics æ•°ç»„ åŠ¨æ€è§„åˆ’ ğŸ‘ 1279 ğŸ‘ 0

/**
 * 416
 *
 * æˆ‘ä»¬å°†ç»™å®šé›†åˆæ‰€æœ‰å…ƒç´ çš„å’Œè®°ä¸ºsumï¼Œé‚£ä¹ˆæœ¬é¢˜å¯ä»¥è§†ä¸ºæ˜¯å¦å­˜åœ¨å­é›†çš„å’Œä¸ºsum/2çš„0-1èƒŒåŒ…é—®é¢˜ï¼Œ
 * å½“sumæ˜¯å¥‡æ•°çš„æ—¶å€™ä¸€å®šä¸ºfalse
 *
 * (1)ç¡®å®šåŠ¨æ€è§„åˆ’æ•°ç»„dp[i][j]
 *      è¡¨ç¤ºå¤„ç†åˆ°ç¬¬iä¸ªå…ƒç´ æ—¶å…ƒç´ å’Œæ˜¯å¦å¯ä»¥ä¸ºj
 * (2)ç¡®å®šçŠ¶æ€è½¬ç§»æ–¹ç¨‹:dp[i][j] = (j >= nums[i] && dp[i - 1][j - nums[i]]) || dp[i - 1][j];
 *      å¦‚æœå½“å‰éå†åˆ°çš„å…ƒç´ ä¸è¿›è¡Œå¤„ç†é‚£ä¹ˆï¼Œé‚£ä¹ˆå…ƒç´ å’Œæ˜¯å¦èƒ½ä¸ºjå–å†³äºï¼Œä¹‹å‰çš„å…ƒç´ å’Œæ˜¯å¦èƒ½ä¸ºjï¼Œdp[i][j] = dp[i - 1][j]
 *      å¦‚æœå½“å‰éå†åˆ°çš„å…ƒç´ è¿›è¡Œå¤„ç†çš„è¯ï¼Œåˆ†ä¸ºä¸¤ç§æƒ…å†µ
 *          å¦‚æœj>=å½“å‰å¤„ç†åˆ°çš„å…ƒç´ å€¼ä¹Ÿå°±æ˜¯j>=nums[i]ï¼Œé‚£ä¹ˆdp[i][j] = dp[i - 1][j - nums[i]]
 *          å¦‚æœj<å½“å‰å¤„ç†åˆ°çš„å…ƒç´ å€¼ï¼Œä¹Ÿå°±æ˜¯j<nums[i]ï¼Œé‚£ä¹ˆdp[i][j] = false
 * (3)åˆå§‹åŒ–ï¼š
 *      dp[0][0] ä»£è¡¨å½“å‰å¤„ç†åˆ°ç¬¬0ä¸ªå…ƒç´ çš„å’Œä¸º0ï¼Œåªè¦ä¸æŠŠå½“å‰å…ƒç´ æ”¾å…¥å­é›†å³å¯ï¼Œæ‰€ä»¥dp[0][0] = true
 *      dp[0][j] å½“j = nums[0]çš„æ—¶å€™ä¸ºtrueï¼Œå…¶ä½™å€¼ä¸ºfalse
 *
 */

public class PartitionEqualSubsetSum {
    public static void main(String[] args) {
        Solution solution = new PartitionEqualSubsetSum().new Solution();
    }

    class Solution {
        public boolean canPartition(int[] nums) {
            int length = nums.length;
            int sum = 0;
            for (int i = 0; i < length; i++) {
                sum = sum + nums[i];
            }

            if (sum % 2 == 1) {
                return false;
            }

            int half = sum / 2;

            boolean[][] dp = new boolean[length][half + 1];
            dp[0][0] = true;
            for (int j = 1; j < half; j++) {
                if (j == nums[0]) {
                    dp[0][j] = true;
                } else {
                    dp[0][j] = false;
                }
            }

            for (int i = 1; i < length; i++) {
                for (int j = 0; j <= half; j++) {
                    dp[i][j] = (j >= nums[i] && dp[i - 1][j - nums[i]]) || dp[i - 1][j];
                }
            }

            return dp[length - 1][half];
        }
    }

}